---
title: "「C和指针」笔记"
date: 2023-02-05T20:31:35+08:00
tags: ["c"]
categories: ["阅读"]
draft: false
---

## C和指针

c语言中的对象必须有且只有一个定义，但它可以有多个extern声明。

区别声明和定义

声明相当于普通的声明：它所说明的并非自身，而是描述其他地方的创建的对象。

定义相当于特殊的声明：它为内存分配对象。

按位与经常用于屏蔽某些二进制位

```c
n = n & 0177
// 将n中除7个低二进制位外的其他各位均置为1
```

按位或运算符常用于将某些二进制位置为1

```c
x = x | SET_ON
// 将x对应于SET_ON中为1的那些二机制位置为1
```

宏中使用 `#` 作前缀则结果将被拓展为由实际阐述替换该参数的带引号的字符串。

```c
#define dprint(expr) printf(#expr " = %g\n", expr)
dprint(x/y)
printf("x/y" " = %g\n", x/y);
```

预处理器运算符 ## 为宏拓展提供了一种连接实际参数的手段。

## static

1. 修饰全局变量起到模块隔离的作用，使用后只有该源文件可以访问，其他源文件不能访问
2. 修饰局部变量时,初始化是在编译期，之后访问函数时只会使用到上次的值，不会在运行初始化语句。
3. 当将局部变量声明为静态局部变量的时候，也就改变了局部变量的存储位置，即从原来的栈中存放改为静态存储区存放。这让它看起来很像全局变量，其实静态局部变量与全局变量的主要区别就在于可见性，静态局部变量只在其被声明的代码块中是可见的

静态局部变量一般的使用场景，如下所示：

- 需要保留函数上一次调用结束时的值。
- 如果初始化后，变量只会被引用而不会改变其值，则这时用静态局部变量比较方便，以免每次调用时重新赋值。

[http://c.biancheng.net/view/301.html](http://c.biancheng.net/view/301.html)

## typedef

typedef 声明的写法与普通声明基本相同，只是typedef这个关键字出现在前面。

```c
char *ptr_to_char;
typedef char *ptr_to_char;
```

## const

```c
// int const 与 const int 一样，只是风格的区别

int const *pci;  // 指向整形常量的指针，可以修改指针的值，但不能修改它所指向的值。

int * const cpi; // 声明cpi是一个指向整形的常量指针，指针是常量无法修改，但可以修改它所指向的整形的值

int const * const cpci; // 无论是指针本身还是它所指的值都是常量，不允许修改

// *const 常量指针。
```

## 链接属性

当组成一个程序的各个源文件分别被编译后，如果相同的标识符出现在几个不同的源文件中时，他们表示相同的实体还是不同实体？标识符的**链接属性
(linkage)**
决定如何处理不同的文件中出现的标识符。标识符的作用域与它的链接属性有关，但两个属性并不相同。

链接属性一共有3种 external（外部的），internal（内部）和none（无）。

1. 没有链接属性的标识符（none）总是被当作单独的个体，也就是说该标识符的多个声明被当作独立不同的实体。
2. 属于internal链接属性的标识符在同一源文件中的所有声明都指向同一实体，但位于不同源文件的多个声明则分属不同的实体。
3. 属于external链接属性的标识符无论被声明多少次，位于几个源文件都表示同一实体。

```c
typedef char *a; // 1  none
int b; // 2   external
int c (int d) { // c -> 3 external;  d -> 4  none;
	int e; // 5  none 
	int f (int g); // f -> 6 external  g ->7  none;
}
```

在缺省情况下,标识符b, c, f
的链接属性为external,其余标识符的链接属性则为none。因此，如果另外一个源文件也包含了标识符b的类似声明并调用函数c,它们实际上访问的是这个源文件所定义的实体。f属性之所以是external是因为它是个函数名。在这个源文件中调用函数f，它实际上将链接到其他源文件所定义的函数，甚至这个函数的定义可能出现在某个函数库。

关键字extern 和 static
用于在声明中修改标识符的链接属性。如果某个声明在正常情况下具有external链接属性，在他面前加static关键字可以使它的链接属性变成internal。

static 只对缺省链接属性为external的声明才有改变链接属性的效果。

extern
关键字的规则更为复杂，一般而言，它为一个标识符指定external链接属性，这样就可以访问通过在其他任何位置定义的这个实体。

## 存储类型

变量的存储类型（storage
class）是指存储变量值的内存类型。变量的存储类型决定变量何时创建，何时销毁以及他的值将保持多久。有三个地方可以用于存储变量：普通内存，运行时堆栈，硬件寄存器。

变量的缺省存储类型取决于它的声明位置。凡是在任何代码块之外的声明的变量总是存储于静态内存中，也就是不属于堆栈的内存，这类变量成为静态变量。对于这类变量，无法为它们指定其他存储类型。静态变量在程序运行之前创建，在程序的整个执行期间始终存在。它始终保持原先的值，除非给他赋一个不同的值或程序结束。

在代码块内部声明的变量的缺省类型是自动的，也就是说它存储于堆栈中，称为自动变量。在程序执行到声明自动变量的代码块时，自动变量才创建，当程序执行流离开该代码块时，这些变量便自动销毁。对于代码块内部声明的变量，如果给他加上关键字static，可以使他的存储类型从自动变成静态。具有静态存储类型的变量在整个程序执行过程中一直存在，而不仅仅在声明他的代码块的执行时存在。**注意，修改变量的存储类型并不表示修改该变量的作用域，它仍然只能在该代码块内部按名字访问**。函数的形式参数不能声明为静态，因为实参总是在堆栈中传递给函数，用于支持递归。

### static关键字

当它用于函数定义时，或者用于代码块之外的变量声明时，static关键字用于修改标识符的链接属性，从external改为internal,但标识符的存储类型和作用域不受影响。用这种方式声明的函数或变量只能在声明它们的源文件中访问。

当它用于代码块内部的变量声明时，static关键字用于修改变量的存储类型，从自动变量修改成静态变量，但变量的链接属性和作用域不受影响。用这种方式声明的变量在程序执行之前创建，并在程序的真个执行期间一直存在，而不是每次在代码块开始执行时创建，在代码执行完毕后销毁。

## c和指针中的补充概念

| 作用域       | 链接属性     | 存储类型   |
| ------------ | ------------ | ---------- |
| 代码块作用域 | external外部 | 普通内存   |
| 文件作用域   | internal内部 | 运行时堆栈 |
| 原型作用域   | none         | 硬件寄存器 |
| 函数作用域   |              |            |

## 左值和右值

左值是能出现在赋值符号左边的值东西，右值就是可以出现在赋值符号右边的东西。

```c
a = b  + 25;
// a 是左值，因为他标识了一个可以存储结果枝的地点
// b + 25 是右值，因为指定了一个值。
b + 25 = a;
// 原来用作左值的a此时可以当作右值，因为每个位置都包含一个值。
// 然后 b + 25 不能作为左值，因为他并未标识一个特定的位置。
```

当计算机计算 b+25
时，它的结果必然保存于机器的某个位置。但是，程序员并没有办法预测该结果会存储在什么地方，也无法保证这个表达式的值下次还会存储于那个地方。基于同样地理由，字面值常量也都不是左值。

## 指针

变量的值就是分配给该变量的内存位置所存储的数值，即使是指针变量也不例外。

间接访问操作符是少数几个其结果为左值的操作符之一。

## 数组

在几乎所有使用数组名的表达式中，数组名的值是一个指针常量，是指向数组第一个元素的指针。只有在两种情况下数组名并不用指针常量来表示——就是当数组名作为sizeof操作符或单目操作符号&的操作数时。sizeof
返回整个数组的所占用的字节，而不是指向数组的指针的占用的字节。
取一个数组名的地址产生的是一个指向数组的指针，而不是一个指向某个指针常量值的指针。

下标表达式 `array[value]` 和间接访问表达式 `*(array+(value))` 是一样的。

```c
int a[10];
int b[10];
c = &a[0]; //表达式 &a[0] 是一个指向数组第一个元素的指针，那正是数组名本身的值
c = a;// 与上面效果一致
```

## 静态和自动初始化（c和指针 p152)

数组和标量初始化方式类似——取决于他们的存储类型。存储于静态内存的数组只初始化一次，也就是在程序开始执行之前。程序并不需要执行指令把这些值放在合适的位置，它们一开始就在那里了。这个魔术由链接器完成的，它用包含可执行程序的文件中合适的值对数组元素进行初始化。如果数组未被初始化，数组元素的初始值将会自动设置为零。当这个文件载入到内存中准备执行时，初始化后的数组值和程序指令一样也被载入到内存中。因此当程序执行时，静态数组已经初始化完毕。

自动变量位于运行时堆栈中，执行流每次进入他们所有在的代码块时，这类变量每次所在的内存位置可能并不相同。在程序开始之前，编译器没有办法对这些位置进行初始化。所以，自动变量在缺省情况下时未初始化的。如果自动变量的声明给出了初始值，每次当执行流进入自动变量声明所在的作用域时，变量就被一条隐式的赋值语句初始化。这条隐式的赋值语句和普通的赋值语句一样需要时间和空间执行。数组的问题在于初始化列表中可能有很多值，这就可能会产生许多赋值语句。对于那些非常庞大的数组，他的初始化时间可能非常可观。

因此，这些需要权衡利弊。当数组的初始化局部于一个函数（或代码块）时，应该仔细考虑一下，在程序每次进入该函数（或代码块）时，每次对数组进行重新初始化是不是值得。如果答案是否定的，你就把数组声明为static，这样数组的初始化只需在程序开始之前执行一次。

## 字符数组的初始化

```c
char message[] = {'H', 'e', 'l', 'l', 'e', 0};
char message[] = "hello";  // 快速方法 等效于上面的方式
```

分辨字符串常量和这种列表初始化快速记法，根据上下文环境进行区分。当用于初始化一个字符数组是，他就是一个初始化列表，其他任何地方，它都表示一个字符串常量。

```c
char message1[] = "Hello"; 
char *message2 = "hello"; //字符串常量
```

## 多维数组

多维数组的元素存储顺序按照最右边的下标率先变化的原则，称为行主序

```c
int matrix[6][10];
int *mp;
mp = &matrix[3][8];
printf("First value is %d\n", *mp); // matrix[3][8]
printf("Second value is %d\n", *++mp); //matrix[3][9]
printf("Third value is %d\n", *++mp); //matrix[4][0]
```

int matrix[3][10]

matrix 它的类型是“指向包含10个整型元素的数组的指针”它的值是：

![matrix](/images/pointers_on_c/matrix.png)

它指向包含10个整型元素的第一个子数组

表达式

matrix + 1

也是一个“指向包含10个整形元素的数组的指针”，但它指向matrix的另一行：

![matrix1](/images/pointers_on_c/matrix1.png)

因为1这个值根据包含了10个整形元素的数组的长度进行调整，所以它指向matrix的下一行。

`*（matrix+1）`事实上标识一个包含10个元素的子数组。它的类型是“指向整型的指针”

`*（matrxi+1）+5`
前一个表达式是个指向整型值的指针，所以5这个值根据整型的长度进行调整。

整个表达式的结果是一个指针，它指向的位置比原先那个表达式所指向的位置向后移动了5个整形元素。

![matrix15](/images/pointers_on_c/matrix15.png)

对其执行间接访问操作:

`*( *( matrix + 1 ) + 5)`
它访问的正是图中的那个整型元素。如果作为右值使用，就取得存储于那个位置的值。如果作为左值使用，这个位置将存储一个新值。

把子表达式 `*(matrix+1)` 改写成`matrix[1]` 得到 `*(matrix[1] + 5)`
再次用下标替代间接访问，所以这个表达式还可以写成`matrix[1][5]`

下标是从左向右计算的，数组名是一个指向第一维第一个元素的指针，所以第一个下标根据该元素的长度进行调整。它的结果是一个指向那一维所需元素的指针。间接访问符号随后选择那个特定的元素。由于该元素本身是个数组，所以这个表达式的类型是一个指向下一维第1个元素的指针。下一个下标值根据这个长度进行调整，这个过程重复，直到所有下标均计算完毕。

## 指向数组的指针

```c
int vector[10], *vp = vector;// 正确
int matrix[3][10], *mp = matrix; // 前面正确，后面错误。
```

matrix
并不是一个指向整型的数组，而是一个指向整型数组的指针。该如何声明一个指向整形数组的指针呢。

`int (*p)[10];`
对于这种声明首先假定它是一个表达式并对他求值。下标引用的优先级高于间接访问，但由于括号的存在，首先执行的还是间接访问。所以p是一个指针，但它指向什么呢？

接下来是下标引用，所以p指向某种类型的数组。这个声明表达式没有更多的操作符，所以数组的每个元素都是整数。

声明没有直接告诉你p是什么，但推断它的类型并不困难——当我们对他执行间接访问操作是，我们得到的是个数组，对该数组进行下标引用得到的是一个整型值。所以p是一个指向整型数组的指针。

`int (*p)[10] = matrix;` 它使p指向matrix的第一行。

p是一个指向拥有10个整型元素的数组的指针，当把p与一个整数相加是，该整数值首先根据10个整型值的长度进行调整，然后在执行加法。所以可以使用这个指针一行一行地在matrix中移动。

当需要逐个访问整型数组 而不是逐行移动

```c
int *pi = &matrix[0][0];
int *pi = matrix[0];
```

避免 `int (*p)[]=matrix`
这种声明，当某个整数与这种类型的指针执行指针运算时，它的值将根据空数组的长度进行调整（也就是说，与零相乘）。

### 作为函数参数的多维数组

作为函数参数的多维数组名的传递方式和一维数组名相同——实际上传递的是指向数组第1个元素的指针。但是，二者的区别在于，多维数组每个元素本身是另外一个数组，编译器需要知道它的维度。

```c
// 一维数组
int vector[10];
func1(vector);
void func1(int *vec);
void func1(int vec[]);
// 二维数组
int matrix[3][10];
func2(matrix);
void func2(int (*mat)[10]);
void func2(int mat[][10]);
void func2(int **mat); // 错误，这里把mat声明称一个指向整型指针的指针，
                       //它和指向整型数组的指针不是一回事
```

## 指针数组

`int *api[10]`

下标引用的优先级高于间接访问，所以在这个表达式中，首先执行下标引用。因此，api是某种类型的数组。在取得一个数组元素后，随即执行的是间接访问操作，这个表达式不再有其他操作符，所以它的结果是一个整型值。

对数组某个元素执行间接访问操作后，我们得到一个整型值，所以api肯定是个数组，它的元素类型是指向整型的指针。

## 结构和联合

`struct **tag** { *member-list* } *variable-list* ;`

所有可选部门不能全部省略，它们至少要出现两个。（例外是结果标签的不完整声明）

### 结构的自引用

```c
struct SELF_REF1 {
	int a;
	struct SELF_REF1 b;
	int c;
}; // 这种类型的自引用是非法的
struct SELF_REF1 {
	int a;
	struct SELF_REF1 *b;
	int c;
}; // 编译器在结构的长度确定之前就已经知道指针的长度，所以这种类型的自引用是合法的
```

如果你觉得结构内部包含一个指向该结构本身的指针有些奇怪，请记住它事实上所指向的是同一种类型的**不同**结构。

```c
//警惕下面的陷阱
typedef struct {
	int a;
	SELF_REF3 *b;
	int c;
}SELF_REF3;
//这个声明的目的是为这个结构创建类型名SELF_REF3。但是他失败了。
// 类型名直到声明的末尾才定义，所以在结构声明的内部它尚未定义。
// 解决方法是定义一个结构标签来声明b
typedef struct SELF_REF3_TAG {
	int a;
	struct SELF_REF3_TAG *b;
	int c;
}SELF_REF3;
```

### 不完整声明

如果每个结构都引用了其他结构的标签，哪个结构应该首先声明呢？

解决方案是使用不完整声明(incomplete
declaration)，它声明一个结构标签的标识符。然后可以把这个标签用在不需要知道这个结构的长度的声明中，如声明指向这个结构的指针。接下来的声明把这个标签与成员列表联系在一起。

```c
//考虑下面的例子，两个不同类型的结构内部都有一个指向另一个结构的指针
struct B;

struct A {
	struct B *partner;
};

struct B {
	struct A *partner;
};
//在A的成员列表里需要标签B的不完整的声明。一旦A被声明之后，B的成员列表也可以被声明。
```

`offsetof (type, member)` 宏，定义于stddef.h
type是结构的类型，member是需要的成员名。结果是一个size_t值，表示这个指定成员开始存储的位置距离结构开始存储的位置偏移几个字节。

## 联合

联合变量可以被初始化，但这个初始值必须是联合第一个成员的类型

## 动态内存分配

```jsx
void *malloc(size_t size);
void free(void *pointer);
void *calloc(size_t num_elements,
             size_t element_size );
void *realloc(void *ptr, size_t new_size);
```

malloc 所分配的是一块连续的内存。

alloc 与 malloc 之间主要的区别是，calloc在返回指向内存的指针之前把它初始化为0.

realloc
函数用于修改一个原先已经分配的内存块大小。使用这个函数可以使一块内存扩大或缩小。

如果扩大原来的内存依然保留。如果原来的内存块无法改变大小，realloc
将分配另一块正确大小的内存，并把原先那块内存的内容复制到新的块上。因此使用人realloc
之后，就不能再使用指针指向旧内存的指针，而应该改用 realloc 所返回的新指针。如果
realloc 第一个参数是NULL，那么他的行为就和 malloc 一模一样。

## 使用结构和指针

### 单链表

定义：在单链表中，每个节点包含一个指向链表下一节点的指针。链表最后一个节点的**指针字段**的值为NULL，提示链表后面不再有其他节点。在你找到链表的第1个节点后，指针就可以带你访问剩余所有节点。为了记住链表的起始位置，可以使用一个根指针（root
pointer）。根指针指向链表的第1个节点。**注意根指针只是一个指针，它不包含任何数据。**

![linekd](/images/pointers_on_c/linked.png)

通过c能够**取得现存对象的地址**这一能力，可以简化掉在链表中头部插入的步骤。

链表中的每个节点都有一个指向它的指针。对于第一个节点，这个指针是根指针；对于其他节点，这个指针是前一个节点的link字段。重点在于每个节点都有一个指针指向它。至于该指针是不是位于一个节点的内部则无关紧要。
