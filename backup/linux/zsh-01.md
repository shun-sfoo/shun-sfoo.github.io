# zsh 学习 1-变量

### 变量定义

Zsh 的变量多数情况不需要提前声明或者指定类型,

可以直接赋值和使用 (但哈希表是一个例外).

双引号里可以使用变量，而单引号不可以 `($var)`.

单双引号均可在字符串使用转义字符.

`echo` 输出变量，也可以使用 `print`.

数组的位置从 `1` 开始.
`-1` 是最后一个字符.

### 变量比较

`(( ))` 用于数值比较等操作, 如果为真返回 0, 否则返回 1.

`((` 中的变量名可以不用 `$`

比较字符串要用 `[[`, 内侧要有空格.

`[[` 中双等号可以替换成单等号. **规范使用双等号**

### 语句

#### 条件语句

如果不确定语法是否符合预期, 可以定义一个函数然后使用 `which` 查看, 内容会被转化成原始 (posix shell 风格) 的样子

```zsh
# 格式
if [[ ]] {
} elif {
} else {
}
```

`[[ ]]` 用于比较字符串, 判断文件等. 注意尽量不要用 `[[ ]]` 比较数值, 因为不留神的话, 数值会被转化成字符串来比较, 没有任何错误提示, 但结果可能不符合预期, 导致不必要的麻烦.

```zsh
# 样例
if [[ "$str" == "name" || "$str" == "value" ]] {
    echo "$str"
}
```

`(( ))` 用于比较数值, 里边可以调用各种数值相关的函数

```zsh
# 格式
if (( )) {
}
# 样例
if ((num > 3 && num + 3 < 10)) {
    echo $num
}
```

`{ }` 用于在当前 shell 运行命令并且判断运行结果.

```zsh
# 格式
if { } {
}
# 样例
if {grep sd1 /etc/fstab} {
    echo good
}
```

`( )` 用于在子 shell 运行命令并且判断运行结果，用法和 `{}` 类似.

这几种括号可以一起使用, 这样可以同时判断字符串, 数值, 文件, 命令结果等等.

最好不要混合使用 `&& ||`, 会导致可读性变差和容易出错.

```zsh
# 格式
if [[ ]] && (( )) && { } {
}
```

#### 循环语句

```zsh
# 格式
while [[ ]] {
    break/continue
}
```

和 `if` 一样, 这里的 `[[ ]]` 可以替换成其他几种括号, 功能也是一样的.

break 用于结束循环, continue 用于直接进入下一次循环.

所有的循环语句中都可以使用 break 和 continue.

```zsh
# 样例 死循环
 while (( 1 )) {
    echo good
}
```

`until` 和 `while` 相反, 不满足条件时运行, 一旦满足则停止, 其他的用法和 while 相同

```zsh
# 格式
until [[ ]] {
}
```

`for` 循环主要用于枚举, 这里的括号是 `for` 的特有用法, 不是在子 shell 执行.

括号内是字符串 (可放多个, 空格隔开), 数组 (可放多个) 或者哈希表 (可放多个, 哈希表是枚举值而不是键). `i` 是用于枚举内容的变量名, 变量名随意.

```zsh
# 格式
for i ( ) {
}
# 样例
for i (aa bb cc) {
    echo $i
}

# 枚举当前目录的 txt 文件
for i (*.txt) {
    echo $i
}

# 枚举数组
array=(aa bb cc)
for i ($array) {
    echo $i
}
```

经典的 c 风格 for 循环.

```zsh
# 格式
for (( ; ; )) {
}
# 样例
for ((i=0; i < 10; i++)) {
    echo $i
}
```

这个样例只是举例,实际上多数情况不需要使用这种 for 循环,可以这样.

```zsh
# 样例，{1..10} 可以生成一个 1 到 10 的数组
for i ({1..10}) {
    echo $i
}
```

`repeat` 语句用于循环固定次数, n 是一个整数或者内容为整数的变量.

```zsh
# 格式
repeat n {
}
# 样例
repeat 5 {
    echo good
}
```

#### 分支语句

分支逻辑用 `if` 也可以实现, 但 `case` 更适合这种场景, 并且功能更强大.

```zsh
# 格式 + 样例
case $i {
    (a)
    echo 1
    ;;

    (b)
    echo 2
    # 继续执行下一个
    ;&

    (c)
    echo 3
    # 继续向下匹配
    ;|

    (c)
    echo 33
    ;;

    (d)
    echo 4
    ;;

    (*)
    echo other
    ;;
}
```

`;;` 代表结束 case 语句, `;&` 代表继续执行紧接着的下一个匹配的语句（不再进行匹配）, `;|` 代表继续往下匹配看是否有满足条件的分支.

#### 用户输入选择语句

`select` 语句是用于根据用户的选择决定分支的语句, 语法和 `for` 语句差不多, 如果不 `break`, 会循环让用户选择.

```zsh
# 格式
select i ( ) {
}
# 样例
select i (aa bb cc) {
    echo $i
}
# 输出是这样的。
1) aa  2) bb  3) cc
?#
```

#### 异常处理语句

```zsh
# 格式
{
    语句 1
} always {
    语句 2
}
```

如果语句 1 执行出错, 则执行语句 2.

#### 简化的条件语句

`if` 语句的简化版, 在只有一个分支的情况下更简洁, 功能和 `if` 语句类似

```zsh
格式：
[[ ]] || {
}

[[ ]] && {
}
```

最好不要连续混合使用 `&& ||`, 比如:

`aa && bb || cc && dd`

容易导致逻辑错误或者误解，可以用 `{ }` 把语句包含起来.

`aa && { bb || { cc && dd } }`

比较复杂的判断还是用 `if` 可读写更好, `&& ||` 通常只适用于简单的场景.
