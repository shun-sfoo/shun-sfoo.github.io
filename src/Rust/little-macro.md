# 申明宏 过程宏

# `macro_rules!` 申明宏

在说起 `macro_rules!` （声明宏）之前，应当讨论一般机制：语法拓展。
宏正是在这个机制之上构建的。
为了解释这个机制，我们必须探讨 Rust 源代码是如何被编译器处理的，
以及构建用户自定义的 `macro_rules!` 宏的一般机制。

标识化

语法解析

形式

```rust
macro_rules! $name {
    $rule0 ;
    $rule1 ;
    // …
    $ruleN ;
}
```

至少得有一条规则 (rule) ，最后一条规则后面的分号可被省略。
规则里你可以使用大/中/小括号：{}、[]、()。 每条“规则”都形如：
`($matcher) => {$expansion}`

如前所述，分组符号可以是任意一种括号，在模式匹配外侧使用小括号、表达式外侧使用大括号只是出于传统。
有末尾分号的宏调用 总是 会被解析成一个条目 (item)。

Rust 是通过操作抽象语法树，达到语法拓展的目的的实现宏
