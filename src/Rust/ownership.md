# Rust 所有权

# 语句和表达式

Rust 是一门基于表达式（expression-based）的语言

- 语句（Statements）是执行一些操作但不返回值的指令
- 表达式（Expressions）计算并产生一个值

使用 `let` 关键字创建变量并绑定一个值是一个语句。
表达式可以是语句的一部分
if 是表达式

# 所有权

Rust 的核心功能之一是 **所有权**。
通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。
在运行时，所有权系统的任何功能都不会减慢程序。

# 栈与堆

像 Rust 这样的系统编程语言中，
值是位于栈上还是堆上在更大程度上影响了语言的行为以及为何必须做出这样的抉择。

栈中的所有数据都必须占用已知且固定的大小。在编译时大小未知或大小可能变化的数据，要改为存储在堆上。
堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。操作系统在堆的某处找到一块足够大的空位，
把它标记为已使用，并返回一个表示该位置地址的 指针（pointer）。这个过程称作 在堆上分配内存（allocating on the heap），
有时简称为 “分配”（allocating）。将数据推入栈中并不被认为是分配。因为指针的大小是已知并且固定的，
你可以将指针存储在栈上，不过当需要实际数据时，必须访问指针。
当你的代码调用一个函数时，传递给函数的值（包括可能指向堆上数据的指针）和函数的局部变量被压入栈中。
当函数结束时，这些值被移出栈。

## 所有权规则

1. Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。
2. 值在任一时刻有且只有一个所有者。
3. 当所有者（变量）离开作用域，这个值将被丢弃。.

## 变量作用域

内存在拥有它的变量离开作用域后就被自动释放。

```rust
fn main() {
    let s = String::from("hello"); // 从此处起，s 是有效的
    println!("{}", s);
} // 此作用域已结束，
  // s 不再有效

```

这是一个将 String 需要的内存返回给操作系统的很自然的位置：当 s 离开作用域的时候。
当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 drop，在这里 String 的作者可以放置释放内存的代码。
Rust 在结尾的 } 处自动调用 drop。

### 变量与数据交互的方式（一）：移动

Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何 自动 的复制可以被认为对运行时性能影响较小

### 变量与数据交互的方式（二）：克隆

Rust 有一个叫做 Copy trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上。
如果一个类型拥有 Copy trait，一个旧的变量在将其赋值给其他变量后仍然可用。
Rust 不允许自身或其任何部分实现了 Drop trait 的类型使用 Copy trait。
如果我们对其值离开作用域时需要特殊处理的类型使用 Copy 注解，将会出现一个编译时错误。

### 类型为 copy

可以查看给定类型的文档来确认，不过作为一个通用的规则，任何简单标量值的组合可以是 Copy 的，
不需要分配内存或某种形式资源的类型是 Copy 的

- 所有整数类型，比如 u32。
- 布尔类型，bool，它的值是 true 和 false。
- 所有浮点数类型，比如 f64。
- 字符类型，char。
- 元组，当且仅当其包含的类型也都是 Copy 的时候。
  比如，(i32, i32) 是 Copy 的，但 (i32, String) 就不是。

### 所有权和函数

将值传递给函数在语义上与给变量赋值相似。
向函数传递值可能会移动或者复制，就像赋值语句一样。

### 返回值与作用域

返回值也可以转移所有权。
变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。
当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，
除非数据被移动为另一个变量所有。

## 引用与借用

`&` 符号就是 引用，它们允许你使用值但不获取其所有权。

![示意图](../static/Rust/reference.svg)

```rust
let s1 = String::from("hello");
let len = calculate_length(&s1);
fn calculate_length(s: &String) -> usize { // s 是对 String 的引用
    s.len()
} // 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，
  // 所以什么也不会发生
```

`&s1` 语法让我们创建一个 指向 值 s1 的引用，但是并不拥有它。
因为并不拥有这个值，当引用离开作用域时其指向的值也不会被丢弃。

我们将获取引用作为函数参数称为 **借用**（borrowing）

正如变量默认是不可变的，引用也一样。（默认）不允许修改引用的值。

```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

首先，必须将 s 改为 mut。然后必须创建一个可变引用 `&mut s`
和接受一个可变引用 `some_string: &mut String`。

不过可变引用有一个很大的限制：在特定作用域中的特定数据只能有一个可变引用。
这个限制的好处是 Rust 可以在编译时就避免数据竞争。
**数据竞争**（data race）类似于竞态条件，它可由这三个行为造成：

1. 两个或更多指针同时访问同一数据。
2. 至少有一个指针被用来写入数据。
3. 没有同步数据访问的机制。

数据竞争会导致未定义行为，难以在运行时追踪，并且难以诊断和修复；
Rust 避免了这种情况的发生，因为它甚至不会编译存在数据竞争的代码！

注意一个引用的作用域从声明的地方开始一直持续到最后一次使用为止。

## Slice 类型

另一个没有所有权的数据类型是 slice。
slice 允许你引用集合中一段连续的元素序列，而不用引用整个集合。
“字符串 slice” 的类型声明写作 `&str`
